/**
 * Minified by jsDelivr using Terser v5.39.0.
 * Original file: /npm/quantize@1.0.2/quantize.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
if (!pv) var pv = {map: function (r, n) { var o = {}; return n ? r.map((function (r, t) { return o.index = t, n.call(o, r) })) : r.slice() }, naturalOrder: function (r, n) { return r < n ? -1 : r > n ? 1 : 0 }, sum: function (r, n) { var o = {}; return r.reduce(n ? function (r, t, u) { return o.index = u, r + n.call(o, t) } : function (r, n) { return r + n }, 0) }, max: function (r, n) { return Math.max.apply(null, n ? pv.map(r, n) : r) } }; var MMCQ = function () { function r(r, n, o) { return (r << 10) + (n << 5) + o } function n(r) { var n = [], o = !1; function t() { n.sort(r), o = !0 } return { push: function (r) { n.push(r), o = !1 }, peek: function (r) { return o || t(), void 0 === r && (r = n.length - 1), n[r] }, pop: function () { return o || t(), n.pop() }, size: function () { return n.length }, map: function (r) { return n.map(r) }, debug: function () { return o || t(), n } } } function o(r, n, o, t, u, e, i) { var c = this; c.r1 = r, c.r2 = n, c.g1 = o, c.g2 = t, c.b1 = u, c.b2 = e, c.histo = i } function t() { this.vboxes = new n((function (r, n) { return pv.naturalOrder(r.vbox.count() * r.vbox.volume(), n.vbox.count() * n.vbox.volume()) })) } function u(n, o) { if (o.count()) { var t = o.r2 - o.r1 + 1, u = o.g2 - o.g1 + 1, e = o.b2 - o.b1 + 1, i = pv.max([t, u, e]); if (1 == o.count()) return [o.copy()]; var c, f, a, v, s = 0, p = [], l = []; if (i == t) for (c = o.r1; c <= o.r2; c++) { for (v = 0, f = o.g1; f <= o.g2; f++)for (a = o.b1; a <= o.b2; a++)v += n[r(c, f, a)] || 0; s += v, p[c] = s } else if (i == u) for (c = o.g1; c <= o.g2; c++) { for (v = 0, f = o.r1; f <= o.r2; f++)for (a = o.b1; a <= o.b2; a++)v += n[r(f, c, a)] || 0; s += v, p[c] = s } else for (c = o.b1; c <= o.b2; c++) { for (v = 0, f = o.r1; f <= o.r2; f++)for (a = o.g1; a <= o.g2; a++)v += n[r(f, a, c)] || 0; s += v, p[c] = s } return p.forEach((function (r, n) { l[n] = s - r })), h(i == t ? "r" : i == u ? "g" : "b") } function h(r) { var n, t, u, e, i, f = r + "1", a = r + "2", v = 0; for (c = o[f]; c <= o[a]; c++)if (p[c] > s / 2) { for (u = o.copy(), e = o.copy(), i = (n = c - o[f]) <= (t = o[a] - c) ? Math.min(o[a] - 1, ~~(c + t / 2)) : Math.max(o[f], ~~(c - 1 - n / 2)); !p[i];)i++; for (v = l[i]; !v && p[i - 1];)v = l[--i]; return u[a] = i, e[f] = u[a] + 1, [u, e] } } } return o.prototype = { volume: function (r) { var n = this; return n._volume && !r || (n._volume = (n.r2 - n.r1 + 1) * (n.g2 - n.g1 + 1) * (n.b2 - n.b1 + 1)), n._volume }, count: function (n) { var o = this, t = o.histo; if (!o._count_set || n) { var u, e, i, c = 0; for (u = o.r1; u <= o.r2; u++)for (e = o.g1; e <= o.g2; e++)for (i = o.b1; i <= o.b2; i++)c += t[r(u, e, i)] || 0; o._count = c, o._count_set = !0 } return o._count }, copy: function () { var r = this; return new o(r.r1, r.r2, r.g1, r.g2, r.b1, r.b2, r.histo) }, avg: function (n) { var o = this, t = o.histo; if (!o._avg || n) { var u, e, i, c, f = 0, a = 0, v = 0, s = 0; for (e = o.r1; e <= o.r2; e++)for (i = o.g1; i <= o.g2; i++)for (c = o.b1; c <= o.b2; c++)f += u = t[r(e, i, c)] || 0, a += u * (e + .5) * 8, v += u * (i + .5) * 8, s += u * (c + .5) * 8; o._avg = f ? [~~(a / f), ~~(v / f), ~~(s / f)] : [~~(8 * (o.r1 + o.r2 + 1) / 2), ~~(8 * (o.g1 + o.g2 + 1) / 2), ~~(8 * (o.b1 + o.b2 + 1) / 2)] } return o._avg }, contains: function (r) { var n = this, o = r[0] >> 3; return gval = r[1] >> 3, bval = r[2] >> 3, o >= n.r1 && o <= n.r2 && gval >= n.g1 && gval <= n.g2 && bval >= n.b1 && bval <= n.b2 } }, t.prototype = { push: function (r) { this.vboxes.push({ vbox: r, color: r.avg() }) }, palette: function () { return this.vboxes.map((function (r) { return r.color })) }, size: function () { return this.vboxes.size() }, map: function (r) { for (var n = this.vboxes, o = 0; o < n.size(); o++)if (n.peek(o).vbox.contains(r)) return n.peek(o).color; return this.nearest(r) }, nearest: function (r) { for (var n, o, t, u = this.vboxes, e = 0; e < u.size(); e++)((o = Math.sqrt(Math.pow(r[0] - u.peek(e).color[0], 2) + Math.pow(r[1] - u.peek(e).color[1], 2) + Math.pow(r[2] - u.peek(e).color[2], 2))) < n || void 0 === n) && (n = o, t = u.peek(e).color); return t }, forcebw: function () { var r = this.vboxes; r.sort((function (r, n) { return pv.naturalOrder(pv.sum(r.color), pv.sum(n.color)) })); var n = r[0].color; n[0] < 5 && n[1] < 5 && n[2] < 5 && (r[0].color = [0, 0, 0]); var o = r.length - 1, t = r[o].color; t[0] > 251 && t[1] > 251 && t[2] > 251 && (r[o].color = [255, 255, 255]) } }, { quantize: function (e, i) { if (!e.length || i < 2 || i > 256) return !1; var c = function (n) { var o, t, u, e, i = new Array(32768); return n.forEach((function (n) { t = n[0] >> 3, u = n[1] >> 3, e = n[2] >> 3, o = r(t, u, e), i[o] = (i[o] || 0) + 1 })), i }(e); c.forEach((function () { 0 })); var f = function (r, n) { var t, u, e, i = 1e6, c = 0, f = 1e6, a = 0, v = 1e6, s = 0; return r.forEach((function (r) { t = r[0] >> 3, u = r[1] >> 3, e = r[2] >> 3, t < i ? i = t : t > c && (c = t), u < f ? f = u : u > a && (a = u), e < v ? v = e : e > s && (s = e) })), new o(i, c, f, a, v, s, n) }(e, c), a = new n((function (r, n) { return pv.naturalOrder(r.count(), n.count()) })); function v(r, n) { for (var o, t = 1, e = 0; e < 1e3;)if ((o = r.pop()).count()) { var i = u(c, o), f = i[0], a = i[1]; if (!f) return; if (r.push(f), a && (r.push(a), t++), t >= n) return; if (e++ > 1e3) return } else r.push(o), e++ } a.push(f), v(a, .75 * i); for (var s = new n((function (r, n) { return pv.naturalOrder(r.count() * r.volume(), n.count() * n.volume()) })); a.size();)s.push(a.pop()); v(s, i - s.size()); for (var p = new t; s.size();)p.push(s.pop()); return p } } }(); window.quantize = MMCQ.quantize;
//# sourceMappingURL=/sm/d6e0ecd839f2d779e33b44e7623bc02c12dcb8e42ba790ef6f22ff21b52c8446.map